## 设计模式是什么
1. 设计模式是前人总结的一系列靠谱的解决方案.我们使用这些方案去解决对应的问题.
2. 设计模式像是我们解数学题中的一些规则例如:勾股定理.
3. 学会设计模式的评判标准就是我们只要看到一个场景就可以想到某一种设计模式.
4. 设计模式做的事情是:将不变和变分离,保证变的部分灵活,不变的部分稳定.
## 设计模式5大基本规则
1. 单一功能原则&单一责任原则: 保证一个函数只做一件事情,这样可以防止修改功能A的时候不修改掉功能B.
2. 开放封闭原则:对拓展开放，对修改封闭。说得更准确点，软件实体（类、模块、函数）可以扩展，但是不可修改。
3. 里式替换原则:
4. 接口隔离原则
5. 依赖反转原则
# 设计模式
## 构造器设计模式
1. 构造器做的事情与构造函数相同.将构造的过程稳定化,将传入的值灵活化.例如
```js
class User {
    constructor(name,age){
        this.name = name ;
        this.age = age
    }
    sayHi(){
            console.log('my name is' + this.name)
    }
}
const u = new User('爵士',18)
```
2. 在创建函数中,其实sayHi的行为是永远不会变的,但是它的名字,性别,年纪是会变化的.
## 工厂模式
1. 工厂模式就是 实现一个生产工场,这个工场只需要告诉它,我们想要什么.其他的就不需要我们管了. 
### 简单工厂模式
```js
function createUser(age,name,career){
    let todo = []
    switch(career) {
        case 'coder':
            work =  ['写代码','写系分', '修Bug'] 
            break
        case 'product manager':
            work = ['订会议室', '写PRD', '催更']
            break
        case 'boss':
            work = ['喝茶', '看报', '见客户']
        case 'xxx':
    }
    retrun  new User(name,age,wolk)
}
```
###  抽象工厂模式
1. 抽象工厂是在简单工厂的基础上衍生出来的. 原因其实是因为简单工场扩展时需要大量的去修改 工厂.随着逻辑增多,工厂函数越来越难以理解.
2. 抽象工厂与简单工厂不同.简单工厂是解决通过一些配置创建不同类的,而抽象工场是制定类的标准. 
3. 抽象工厂是将简单工厂中个性化的一些内容独立为类的衍生.这样如果我们进行扩展,只需要新增类.而简单工厂则需要修改工厂本体
```js
class User{
    constructor(name,age){
        this.name = name 
        this.age = age 
    }
    work(){
        throw new Error('不可以直接使用该类创建对象')
    }
}
class Coder extends User{
    work(){
        console.log('写代码','写系分', '修Bug')
    }
}
class Boss extends User{
    work(){
        console.log('喝茶', '看报', '见客户')
    }
}
const xiaoa = new Cloder()
```
1. 目前看起来似乎是没必要的明明一个工厂函数就可以解决为什么要创建多个类,其实不然.现在的 逻辑比较简单,而当逻辑复杂以后扩展每一个角色其实是比较困难的.
2. 创建一个角色我们直接创建一个类不就好了干嘛要继承呢.其实继承的意义在于 封闭原则. 我们只修改可变的.封装不可变的.每个员工都必须打工这件事情就是不可变的.
3. 除此以外我们还对 角色增加了扩展性.这一点其实也是我们必要的一个内容.我们可以给任何角色扩展,也可以以按照规范扩展任何类型.
### 构造器,简单工厂,抽象工厂之间的区别
1. 这3者都是创造形的.
2. 构造器解决的是一类内容的复用.
3. 工厂模式是解决多种类创建的问题.
4. 抽象工厂是简单工厂的一个衍生,它是一些有共性的类的一种标准.
## 单例模式
### 特点
1. 一个类只创建一个实例
2. 提供一个访问它的全局访问点.
3. 不管多少次创建都会返回同一个实例.
### 解决问题
1. 单例模式是为了解决一个东西防止被多次调用.产生与设计不符的场景.
### 单例模式实现
```js
class Vuex {}
Vuex.vue  = null;
Vuex.install = function (_vue) {
    if(Vuex.vue && Vuex.vue === _vue) {
        console.log('重复创建')
        return 
    }
    Vuex.vue = _vue;
}
const vue = {}
const store1 = Vuex.install(vue)
const store2 = Vuex.install(vue)
if(store2 === store1){
    console.log('store 相同')
}
```
### 单例模式
1. 单例模式的本质就是增加缓存机制.
2. 单例模式与闭包配合.
## 原形模式
1. 在其他语言中原形模式的应用就是通过 深拷贝的形式 以一个对象为原形,复制成一个新对象.
2. 在 Javascirpt 中与其他语言不同. Javascript 本实就是基于原形实现的. 类创建就是将 类的 prototype 拷贝到 对象的 __proto__ 属性上 .所以本身 JavaScript 的 原形模式和创建对象是一个概念.
3. 如果要实现其他语言所说的原形模式,则是去讨论深拷贝问题. 
4. 使用 Object.create() 也是原形模式的一种应用.
## 修饰器模式
修饰器模式的核心在于给一个对象增加新的外衣.得到更多功能支持.好比给手机贴了防偷窥膜,让手机有了防偷窥的功能.
### 使用场景
装饰器一般用在为标准功能提供额外配置的场景下. 例如 按扭 经过装饰 可以成为 红色按扭.
### 修饰器的好处
1. 修饰器是对类的一个提升.这样即可在不改变 原有能力的情况下增加新能力.
### Javascript 语法.
1. es5
```js
class Button {
    constructor(dom) {
        this._dom = dom
    }
    click() {
        console.log('click')
    }
}
class Decorator {
    constructor(button) {
        this._button = button
    }
    click() {
        this._button._dom.setAttribute("disabled", true)
    }
}
const button = document.getElementById('button');
const bt = new Decorator(new Button(button))
button.addEventListener('click', () => {
    bt.click()
})
``` 
2. es7
```js
// 装饰器函数，它的第一个参数是目标类
function classDecorator(target) {
    target.hasDecorator = true
  	return target
}

// 将装饰器“安装”到Button类上
@classDecorator
class Button {
    // Button类的相关逻辑
}

// 验证装饰器是否生效
console.log('Button 是否被装饰了：', Button.hasDecorator)
```

```js
function funcDecorator(target, name, descriptor) {
    let originalMethod = descriptor.value
    descriptor.value = function() {
        console.log('我是Func的装饰器逻辑')
        return originalMethod.apply(this, arguments)
    }
    return descriptor
}

class Button {
    @funcDecorator
    onClick() { 
        console.log('我是Func的原有逻辑')
    }
}

// 验证装饰器是否生效
const button = new Button()
button.onClick()

```

## 适配器
### 核心思想
适配器就是将两个需要连接在一起的一个中间件.本身的工作就是 将 A 处理 成 B想要的样子.
### 好处
1. 适配器的好处在于在不破坏 A 的情况下让 B 使用 A. 同时 A 也不存在 B相关的代吗.
### 使用场景
在修改旧代码中公用函数时,我们无法一个个的修改每一个调用点.此时我们可以做一个适配器函数,利用新函数 + 适配器 的方式 修改为旧函数的调用方式.
### 适配器和装饰器
两者都是在 原功能上做扩展.只是装饰器是新增功能,而适配器是为了兼容.
## 代理模式
### 核心思想
代理模式就是产生一个传话筒,我们只能和传话筒沟通.然后传话筒和正主沟通.当然传话筒有很多形式:
1. 缓存代理: 缓存代理就是 中间人为我们保存了信息,我们下次找中间人的时候,它直接告诉我们结果. 我 -> 中间人 -> 她 -> 中间人 -> 我, 我 -> 中间人 -> 我 . 常见例子浏览器缓存.
2. 事件代理: 用在 DOM 上给父DOM增加事件来代理子DOM的事件. 路线变成 点击 dom -> 代理(父) -> 正主 (子)
3. 虚拟代理: 代替正主做事,但是成绩给正主,只做幕后英雄.例如 img 放 占位图,而使用一个幕后英雄img 缓存图片.成功后给到 img .img什么都没做却得到了结果.
4. 保护代理: 保护代理就是中间人是一个拦大门的大爷,当你要找她的时,大爷会先看看你有没有 凭证, 有的话就可以.没有直接让你滚蛋.
总结 代理模式就是找人办事.中间人可以 保存一些以有信息(缓存代理),或者替你办事(虚拟代理),或者成为拦路虎(保护代理),或者成为好多事的一个代理(事件代理)
### 代理的优点
1. 优化结构,让我们的正主做好自己的事情就好.
2. 扩展.
## 策略模式
### 核心思想
策略模式就是提供一系列方案.这些方案都可以在同一个地方使用.得到不同的效果.我们可以通过 对象形式将他们保存.在使用的时候只需要一个key就可以搞定.
### 优点
1. 因为是同一个地方可以使用的策略,所以可扩展性非常好.
2. 因为策略本身是独立的.所以定位比较块.
3. 策略和使用策略,分为两快 内容.错误定位比较方便.
### 常见
插件模式
## 状态模式
### 核心思想
状态模式的核心思想就是通过改变状态,来执行对应的事情.与策略模式很类似,但是策略模式的每个策略是独立的,可以互相替换的.而状态模式是对一个对象的处理.所以处理.每一个状态可以做多件事情.
### 优势
1. 状态模式可以简化逻辑判断.
2. 状态模式是通过状态管理链路的.所以复用链路成本较低.
### 常见
1. 正则
2. 有序状态机
### 状态模式 和 策略模式
1. 状态模式关注的是当前应用的状态,并执行对应状态的代码,而代码本身也可以修改对象本身的状态.从而实现 有限状态机.
2. 策略模式是关注策略本身.提供的是单一服务
3. 策略模式关注的只是策略,是单一的.状态模式关注的是一个对象它是个整体.
## 观察者模式
### 核心思想
观察者模式分为两部分 发布者和观察者.发布者可以收集观察者.并在合适的实际发布信息给观察者.而观察者一直在准备状态,当有信息发布过来时.观察者会开始工作.
### 优势
观察者模式解决的是一个对象的装它发生改变,而促发多个对象的方法执行问题.
### 常见案例
1. vue 变量变化. watch 一个变量  这个变量 发生改变 同志给 watch
## 发布订阅模式
### 核心思想
发布订阅模式是发布者和订阅者还有一个平台.与观察者模式不同,它是由3方组成的
1. 发布者发布一个内容到平台上
2. 订阅者从平台上订阅内容.
3. 当发布者有改变内容时,订阅者可以接到通知.
### 和观察者模式对比
1. 两者都是为了解决 对象发生改变促发其他对象执行问题.
2. 观察者模式和发布订阅模式的差别在于 订阅模式是有中间平台的.所以订阅者可以是多个,发布者也是多个.而观察者是直接1对多的关系.没有中间平台.
### 常见案例
- vue bus 
- mitter
## 迭代器模式
### 核心思想
迭代器的核心思想其实就是解决循环问题. 背后的逻辑其实就是将数据转换为 有序序列.然后 通过一个函数去访问它.
### 优势
1. 迭代器的本质就是给大家提供一个好用的循环方法 . 大家就不需要去考虑如何循环这个问题了.
2. 对于有序的数据结构我们可以使用循环,但是像对象这种无序的结构,我们只能用迭代器去实现.
### 常见案例
1. Array 的 管道函数.
### 实现
1. 将数据转为可迭代数据
2. 通过函数去获取下一个.
3. 组成管道函数.