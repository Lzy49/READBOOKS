# 坏味道
## 神秘命名（改名不单单是改名，还是审视代码）
改名是我们经常要做的事情。但不仅仅是改名，如果一个函数，变量没有一个好的名字，说明这个函数设计可能有问题。这推动我们对函数进行精简。
## 重复代码（减少的不仅仅是写的，还有下次读的和改的）
重复代码合而为一，程序会变得更好。有利于：
1. 代码优化
2. 再次阅读
3. 二次修改
重复代码重构方式有：
1. 同一类的两个函数中，应提炼函数。
2. 两端代码只有细微差异，应`移动语句`，将重复代码`提炼函数`不同代码保留在函数中.
3. 当同一段代码高于一个类 or 模块 应 `函数上移` 避免两个模块互相调用。
## 过长函数（函数越短，活的越长）
怎样将长函数缩短：
1. 寻找注释：提炼函数，函数名表示一段代码做什么，而不是怎么做。
2. 以命令取代函数。
3. 提炼条件和循环
   1. switch : 基于同一条件可以以多态取代条件表达式。
   2. 循环 : 拆分循环，循环中做的事情，单独处理 （不要怕损耗性能）
   3. if : 分界条件表达式
> 不要过分提炼，关注 一段代码是做什么，而不是怎么做。
## 过长参数列表（提炼函数的附属品）
在提炼函数的过程中会产生许多临时变量入参问题。解决方案如下：
1. 向某个参数发起查询另一个参数的值，使用`查询取代参数`去掉第二个。
2. 从现有参数中抽离出很多数项目，就使用`保持对象完整性`一次性传入整个对象。
3. 如果有多参数一起传入，可以用`引入参数对象`将其合并为一。
4. 如果参数被用来区分函数行为，要使用`移除标记参数`
5. 如果有多函数调用同样几个参数，使用`函数组合成类`将共同的参数变成这个类的字段。
## 全局数据（谁改了我的数据？）
全局数据因为无法定位修改位置导致调试困难，所以：
1. 减少全局变量，封装到使用模块中
2. 全局变量常量化
3. 迫不得已的全局变量使用`封装变量`变成查询函数，增加调试接口。
## 可变数据（谁改了我的数据？2.0）
可变数据在小范围内是无关紧要的，但是在长段代码中就要警惕。以以下方案缩小或监控：
1. 可变变量使用`封装变量`增加监听入口。
2. 修改变量，查询变量的函数应该使用将修改函数查询函数分离剔除副作用
3. 一个变量被赋予多种意义，应该使用`拆分变量`拆成多个。并使用`移动语句`，`提炼函数`将查询，修改函数拆分
4. 使用`移除设值`函数来缩小作用域
5. 将以链式取值的形式使用`以查询取代派生变量`减少重复代码。缩小变量作用域。
6. 当多函数调用某变脸更实用`函数组合成类`,`函数组合成变换`来限制作用域。
7. 避免引用对象被修改导致其他函数出错。使用`引用对象改为值对象`
## 发散性变化（分步骤，1 → 2 → 3）
如果代码有先后次序，要使用`拆分阶段`来讲两个不同的逻辑拆分为两个模块。使用`提炼函数` → `搬移函数` → `提炼类` 将已有代码拆分。
## 霰弹式修改（同样的修改拽到一起来）
如果需要再许多不同的类中做许多小修改难以寻找。应该：
1. `搬移函数`，`搬移字段`将需要修改的代码放入一个模块。
2. 多个函数操作类似数据使用`函数组合成类`,
3. 函数功能是转换或者重试数据结果使用`函数组合成变化`，
4. 最后整理逻辑，使用`拆分阶段`来将抽离变化接入霰弹式代码中。
5. 最后用`内联函数`或`内联类`将所有霰弹函数拽到一起。
## 依恋情节(爱就让他们在一起)
在多模块中，一个模块中的函数调用了另一个模块较多的取值函数，则应该将该函数归到这个模块中，让数据和调用函数在一起。如果函数中的部分代码调用多，则提炼函数，再迁移。
## 数据泥团（不要在意给多少，只要在意给对没）
- 当数据项在三五处一起出现时，说明这些数据项应该被揉成一团。运用提炼类来将这些数据项提炼到一起。在运用`引入参数对象` 或 `保持对象完整`来为使用他们的函数瘦身。
- 将数据项提取成类的原因是，可以闻到一些依恋情节的坏味道，从而进一步重构。
- 在一些数据项中，删除一小项，其他项目会因此失去意义，则这些数据项应该产生一个新对象。
### 基本类型偏执（变量不只是变量，还有他相关的一切）
在代码中使用变量，会有一些相关的逻辑。这些逻辑牵涉一个或多个变量。我们应该把这些逻辑和变量独立成一个对象。而不是在代码中散落他们。例如 坐标，可能会有坐标和坐标的距离计算之类的函数。
### 重复 switch（switch 没有错，错的是重复）
switch 语句可以使用 多态来代替，当某一个 case 被单独使用时，可以更为便利。而 switch 被重复使后，多态的扩展也更加便利
### 循环语句（时代眼泪）
循环语句并不是不好，而是有了更好的替代，es6 提供的 迭代器方法完全可以替代循环语句。且更加明确循环的意义。
### 冗余的元素（过分设计）
要在需要的时候再使用，而不是提前预备。要删除 类中只有一个函数，对象中只有一个字段这种，无效的设计代码。
### 夸夸其谈的通用性（用上了再做，用不上就不做）
一次只做给定需求，不要过分设计。通用性固然好，但是如果没有这个需求，就不要去为代码增加负担。
### 临时变量（绑死！绑死）
临时变量应该和使用它的函数抽离成一个新类，而不是散落在全局or局部作用域中。
### 过长的信息链（简单取值，统一取值）
代码中通过`a[1][2][3]`这种形式取值的操作应该和对象一起独立成一个取值函数，外部客户端通过函数取值，这样即使修改了代码的结构，也不需要外部进行修改。
### 中间人（不要二道贩子赚差价）
代码中，如果调用一个功能，应该直接找到定义它的类，而不是委托给另一个对象，这个中间对象又去调用。
### 内幕交易（把私下干的事摆在明面上）
如果两个模块之间有一些耦合的数据或函数。我们应该减少这种耦合。例如：
1. 两个模块有同样的功能，则将这个功能模块独立成一个新模块。两个模块统一使用这个模块。
2. 两个模块在特定场景会频繁互相调用，则应该将它们搬运到这个场景下。减少私下交流。例如A模块的a函数实现了某场景的某功能调用了B模块的某函数，则应该将A模块的a函数搬移到这个场景下的私有函数调用B模块的某函数。
### 过大的类（拆分！拆分）
如果让一个类干太多的事情，则会产生太多字段。这些字段可能只和某几个函数有关。这个时候我们可以将这些独立的函数和字段独立为一个类，而他们耦合的类可以提为一个超类。
### 异曲同工的类（替换）
如果使用一个类替换另一个类时，应该：
1. 改变函数声明，将函数签名变一致
2. 搬移函数一点点的迁移
3. 提炼超类，剔除一些重复代码。
### 纯数据类（不仅仅存数据，还有改变的方法）
纯数据类中的要被访问值应该存在一个访问记录。不可修改的值不能提供修改方法。可修改的值应该将修改它的代码独立成函数并抽离到数据类中。
### 拒绝馈赠（不要假惺惺）
当子类继承父类又不想实现父类提供的一些接口时。应该重构父类，将父类拆分为超类和子类。子类直接继承超类，而不必实现子类的接口。
### 注释（拒绝无效注释）
注释的用途不应该是表述一段代码的用处，而是对代码结构的说明。因为用处已经被抽离为独立函数，而函数名就可以很好的表述。注释可以用来表示：为什么做这个事，这个事有什么特别要说明的点。

 


