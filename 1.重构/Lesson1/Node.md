# 第一章节
## 重构观点
1. 重构的目的是为了下次可以更好的修改它。如果一段代码不会被再次修改。那重构毫无意义。
2. 每次重构准寻营地法则：“走的时候要比来的时候更加健康”。每次编辑一段代码时，要使这段代码比以前更健康
## 重构的流程
### 创建可靠的测试
创建可靠测试的目的是为了在我们进行重构时需要确保代码没有发生错误。而且进行测试是每一个重构点都需要做的。
### 以小步骤的形式重构代码
以小步骤进行的形式进行重构是为了错误发生在最小范围以内。即使熟练也需要进行小步骤测试，提交。
#### 步骤
1. 发现重构点
2. 重构
3. 编译
4. 测试
5. 提交
## 重构手法
### 查询替代临时变量
即 使用一个函数来获取某一个变量。例如
```TypeScript
const obj = {
  info:{
    name:'xx'
  }
}
// const name = obj.info.name // 不这样
const name = getName(obj)
function getName(obj){
  return obj.info.name
}
console.log(`my name is ${name}`)
```
#### 查询替代的好处
- 临时变量的坏处：
  - 只在一个范围内有效。离开这个范围就需要重新定义。
  - 若多个函数使用同作用临时变量则需要多处写临时变量。
- 函数查询的好处：
  1. 只要在传入参数的作用域中调用，即可获取。即使调用的过程复杂也可以重用
  2. 因为后面要抽离局部的一些代码成为一个独立的函数。为了抽离代码更少的传入参数也应该将局部变量提取为函数查询
#### 查询替代的场景
1. 不是所有局部变量都要被替换，如果作用域中逻辑无需抽离或取值方式无其他作用域重复利用，可以不抽离。
2. 查询函数一般要和内联变量结合使用，更香。
3. 查询函数要定义在内部使用变量的作用域内。
### 提炼函数
提炼函数就是将一段单独作用的代码提炼为一个函数。
#### 提炼方法
1. 取一段单独作用代码抽离为一个函数
2. 根据作用起名方便阅读。
3. 分析与全局相关变量
   1. 被提炼代码使用单未更改的，以参数形式传入
   2. 被提炼代码更改，或提炼代码产出的，以返回值形式返回。
4. 将内部一些参数，变量进行重命名。（如有必要）
5. 使用函数替换局部变量或直接内联到代码中.
#### 提炼好处
1. 方便阅读。
2. 保持代码整洁
3. 复用方便
### 内联变量
内联变量就是讲临时变量使用查询函数，或其他全局变量取值的形式直接插入代码中，而不是定义临时变量取值。
#### 好处
- 代码整洁。
#### 场景
- 不是所有地方都内联
- 如果变量被二次使用，或大量修改可以定义为局部变量 or 抽离为查询函数
### 拆分循环
拆分循环就是将一段循环中的多个功能点拆分为多个循环处理。
#### 好处
1. 便于函数抽离，独立功能独立维护
2. 使用循环函数替换循环
3. 方便阅读
#### 坏处
1. 性能下降
### 拆分阶段
拆分阶段的意思是根据阶段来拆分代码，并利用提炼函数将代码语义化。
#### 例
将某用户名字，余额 以 文本形式打印。拆分为：
1. 获取某用户名字，余额
2. 以文本形式打印。
这样的好处有：
1. 分阶段以后，获取值和输出分离。假设某一块内容增加功能例如：以 HTML 形式打印，只需要修改打印阶段的代码即可。
#### 好处
1. 代码清晰
2. 代码分类好，复用性高
### 以多态替换条件表达式
当计算机逻辑的差异由类型代码确定，使用类型多态方案来解决。
#### 例
学校有男女同学，男女同学都需要参加体育考试，但规则不同。这个时候应该使用：学生类作为男，女学生两个类的基类。而男女同学都有考试这个方法，但是行为不同。
#### 好处
1. 扩展性高：如果有新的类型进入，只需要再创建一个子类即可，不需要改所有代码中的逻辑
2. 根据该类型判定的内容越多，使用多态解决越是优越。
3. 基类中可以作为一个保护。防止未扩展类进入。
4. 基类代码复用。
# 代码习惯
1. 函数参数带上类型，使用不定冠词修饰。可以增加函数可读性。
2. 一些变量使用约定俗成的词来表示例如 result 表示返回结果。
3. 将引用类型值交给函数处理时，要深拷贝一下，防止函数内部篡改数据
# 第一章节代码重构思路
1. 以功能点提炼函数，拆分循环。使代码整洁
2. 使用分阶段的方式将 准备数据和打印方式分开。并扩展打印方式。
3. 使用多态替换写死的 switch 逻辑，使扩展戏剧类型时更方便。
# 重点
1. 重构的第一步是有一个可靠的测试。这一点尤其重要
2. 重构应该分为小步走，一个重构点使用 重构 → 编译 → 测试 → 提交 的流程执行。
3. 重构是为了代码更好的阅读性。有时候会牺牲性能。
4. 重构应该基于需求，可能进行。而不是无脑重构。