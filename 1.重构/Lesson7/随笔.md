# 封装记录
## 动机
1. 当数据是可变的，记录形式无法满足。所以考虑使用类封装记录。
2. 类封装记录有一个好处在于新老字段替换。可以定义多个字段来处理。
3. 封装记录仅适用于可变数据或较宽使用场景下，而不可变数据使用记录封装更为合适。
4. 对于记录封装还有一个好处就是可以防止他人更新对象中的值。
## 方法
1. 将记录访问替换为函数访问（函数A）。
2. 创建一个类，将记录包装。
   1. 创建一个属性 = 原始记录
   2. 创建一个方法返回原始记录
3. 修改(函数A)返回类实例执行返回原始记录函数。
4. 测试
5. 新建函数，返回类实在例。（函数B)
6. 对使用记录的每个使用点，将使用(函数A)替换为使用（函数B）
   1. 客户端使用访问函数不存在，则创建对应访问函数。
      1. 客户端访问的函数是简单值直接返回
      2. 客户端访问的值是记录返回副本
   2. 客户端对值进行修改，创建对应修改函数
      1. 客户端修改简单值，创建 set 函数
      2. 客户端修改复杂值，创建修改函数。
7. 移除（函数A）
8. 测试
9. 如果记录中的字段本身也是复杂结构，考虑再次进行封装。
# 封装集合
## 动机
封装类的好处在于可以很容易看清楚数据被修改的地点和修改方式，这样当我们需要更改数据结构时就方便很多。
## 封装方案
1. 永远不直接返回集合值，使用计算属性来返回。
2. 限制集合操作，只允许读的操作。这样不会破坏集合。
3. 设置取值函数返回集合副本。设置添加，删除函数更改原集合。
## 团队开发
不管使用何种方式，要整个团队统一。这样学习成本低。
## 方法
1. 先使用封装变量将集合引用进行封装   
2. 在类上添加 增加元素 和 移除元素 的函数。
3. 执行静态检查。
4. 查找集合引用点，如果调用者直接修改集合，则更改为使用添加/移除函数。
5. 测试
6. 修改集合的取值函数，返回一个只读副本。
7. 测试
# 以对象取代基本类型
## 动机
简单的数据项表示简单的情况。如果这些简单的数据项不简单,则应该为它创建一个新类。
## 方法
1. 如果变量尚未被封装起来，先使用封装变量封装它
2. 为这个值创建一个简单的类。类的构造函数保存这个数据值，并为其提供一个取值函数。
3. 静态检查
4. 修改第一步创建的设值函数，令其创建一个新类的对象，并将其存入字段。如有必要，同事修改字段的类型声明。
5. 测试
6. 考虑对第一步访问函数进行改名。更好的反应其用途
7. 考虑应用将引用对象修改为值对象，或将值对象修改为引用对象。明确指出新对象的角色是值对象还是引用对象。
8. 考虑将使用该变量的地方抽离到类中进行归纳。

# 以查询取代临时变量
## 动机
1. 一些临时变量被多处使用，同样的逻辑应该进行提取。
2. 临时变量以查询代替，让函数逻辑更为纯粹。
3. 在类中直接定义 get 属性即可。在函数中可以利用函数作用域对其进行提升。
## 方法
1. 检查变量在使用前是否已经完全计算完毕。检查计算是否每次都能得到同样的值。
2. 检查变量是不是可以只读。如果可以，改造成只读。
3. 测试
4. 将变量赋值的代码提炼成函数。
   1. 起一个好替换的名字
   2. 保证提炼函数没有副作用
   3. 将变量位置进行替换。
   4. 删除变量。并修改查询函数。
5. 测试
6. 用用内联变量手法，移除临时变量
# 提炼类
## 动机
一个类应该是一个清晰的抽象，只处理一些明确的责任。
## 操作
1. 对于待内联类中的所有 public 函数，在目标类上创建一个对应的函数，新创建的所有函数应该直接委托至源类。
2. 修改源类 public 方法的所有引用点，令他们调用目标类对应的委托方法。
3. 将源类中的函数与数据全部搬移到目标类，每次修改进行测试。直到源类变成空壳。
4. 删除源类。
# 内联类
## 动机
1. 当两个有两个相关联的类，且有一个不再承担足够的责任，则要将这个萎缩类塞进另一个类中。
2. 当想要重新提炼类时，
## 操作
1. 对应待内联类中的所有 public 函数，在目标类上创建一个对应的函数。新创建的所有函数直接委托至源类。
2. 修改源类public 方法的所有引用点，令他们调用目标类对应的委托方法。
3. 将源类中的函数与数据全部搬移到目标类，每次修改后进行测试。直到源类变成空壳。
4. 删除源类。
# 隐藏委托关系
## 动机
隐藏委托关系的好处在于当委托关系发生变化时，只需要修改隐藏关系的类即可，不需要修改应用改数据的每一处角落。
## 操作
1. 对于每个委托关系的函数，在服务对象端建立一个简单的委托函数。
2. 调整客户端，令他只调用服务对象提供的函数。每次调整后运行测试。
3. 如果将来不再有任何客户端需要取用委托类，便可移除服务对象的相关访问函数。
4. 测试。

# 移除中间人
## 动机
受委托关系的附带品会让数据源类成为一个中间人。
## 操作
1. 为委托关系创建一个取值函数
2. 对于每个委托函数，让其客户端转为链接访问函数调用。每次替换后进行测试
# 替换算法
不舒服就得换，不换不行。
## 操作
1. 整理下待替换的算法，保证他已经抽取到一个独立的函数中。
2. 先知为这个函数准备测试，以固定它的行为。
3. 准备另一个算法。
4. 执行静态检测。
5. 进行测试，对比两个函数结果是否相同。相同则进行替换。否则根据旧函数进行调试。